<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Báo Cáo Đồ Án - PokeKawaii Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @page {
            size: A4;
            margin: 2cm;
        }

        body {
            font-family: 'Times New Roman', Times, serif;
            line-height: 1.6;
            color: #000;
            background: white;
            font-size: 13pt;
        }

        .container {
            max-width: 210mm;
            margin: 0 auto;
            padding: 20mm;
            background: white;
        }

        /* Cover Page */
        .cover-page {
            text-align: center;
            page-break-after: always;
            padding-top: 50mm;
        }

        .university {
            font-size: 14pt;
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .faculty {
            font-size: 13pt;
            margin-bottom: 30px;
        }

        .title {
            font-size: 24pt;
            font-weight: bold;
            text-transform: uppercase;
            color: #1a1a1a;
            margin: 40px 0;
            line-height: 1.4;
        }

        .subtitle {
            font-size: 18pt;
            font-weight: bold;
            margin: 30px 0;
            color: #333;
        }

        .student-info {
            text-align: left;
            display: inline-block;
            margin-top: 60px;
            font-size: 13pt;
        }

        .student-info p {
            margin: 10px 0;
        }

        .footer-cover {
            position: absolute;
            bottom: 30mm;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 13pt;
        }

        /* Content Styles */
        h1 {
            font-size: 18pt;
            font-weight: bold;
            text-transform: uppercase;
            text-align: center;
            margin: 30px 0 20px 0;
            color: #1a1a1a;
        }

        h2 {
            font-size: 16pt;
            font-weight: bold;
            margin: 25px 0 15px 0;
            color: #2c3e50;
        }

        h3 {
            font-size: 14pt;
            font-weight: bold;
            margin: 20px 0 10px 0;
            color: #34495e;
        }

        h4 {
            font-size: 13pt;
            font-weight: bold;
            margin: 15px 0 10px 0;
            font-style: italic;
        }

        p {
            text-align: justify;
            margin-bottom: 10px;
            text-indent: 1cm;
        }

        ul, ol {
            margin-left: 40px;
            margin-bottom: 15px;
        }

        li {
            margin-bottom: 8px;
            text-align: justify;
        }

        .code-block {
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-left: 4px solid #2c3e50;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 11pt;
            overflow-x: auto;
            page-break-inside: avoid;
        }

        .algorithm-box {
            background: #f9f9f9;
            border: 2px solid #3498db;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            page-break-inside: avoid;
        }

        .complexity-box {
            background: #fff3cd;
            border: 2px solid #ffc107;
            padding: 12px;
            margin: 10px 0;
            border-radius: 5px;
            page-break-inside: avoid;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            page-break-inside: avoid;
            font-size: 12pt;
        }

        th {
            background: #2c3e50;
            color: white;
            padding: 10px;
            text-align: left;
            font-weight: bold;
            border: 1px solid #000;
        }

        td {
            padding: 10px;
            border: 1px solid #000;
        }

        tr:nth-child(even) {
            background: #f9f9f9;
        }

        .page-break {
            page-break-after: always;
        }

        .diagram {
            background: white;
            border: 2px solid #2c3e50;
            padding: 15px;
            margin: 20px 0;
            font-family: monospace;
            font-size: 11pt;
            page-break-inside: avoid;
        }

        .highlight {
            background: #ffeb3b;
            padding: 2px 5px;
            font-weight: bold;
        }

        .note-box {
            background: #e3f2fd;
            border-left: 4px solid #2196F3;
            padding: 12px;
            margin: 15px 0;
            page-break-inside: avoid;
        }

        .toc {
            margin: 30px 0;
            page-break-after: always;
        }

        .toc-item {
            margin: 8px 0;
            padding-left: 20px;
        }

        .toc-item a {
            text-decoration: none;
            color: #000;
        }

        .section-number {
            font-weight: bold;
            margin-right: 10px;
        }

        .image-placeholder {
            border: 2px dashed #ccc;
            padding: 40px;
            text-align: center;
            margin: 20px 0;
            background: #fafafa;
            page-break-inside: avoid;
        }

        @media print {
            body {
                background: white;
            }
            .container {
                padding: 0;
            }
            .page-break {
                page-break-after: always;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- TRANG BÌA -->
        <div class="cover-page">
            <div class="university">ĐẠI HỌC QUỐC GIA TP. HỒ CHÍ MINH</div>
            <div class="university">TRƯỜNG ĐẠI HỌC CÔNG NGHỆ THÔNG TIN</div>
            <div class="faculty">KHOA CÔNG NGHỆ PHẦN MỀM</div>

            <div style="margin: 40px 0;">
                <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120'%3E%3Ccircle cx='60' cy='60' r='50' fill='%232c3e50'/%3E%3Ctext x='60' y='75' font-size='60' fill='white' text-anchor='middle' font-family='Arial'%3EUIT%3C/text%3E%3C/svg%3E" alt="Logo" style="width: 120px;">
            </div>

            <div class="title">BÁO CÁO ĐỒ ÁN CUỐI KỲ</div>
            <div class="subtitle">Học phần: Phân tích thiết kế giải thuật</div>

            <div style="margin: 40px 0; font-size: 20pt; font-weight: bold; color: #2c3e50;">
                ĐỀ TÀI:<br>
                HỆ THỐNG GAME POKEKAWAII<br>
                <span style="font-size: 16pt;">(Game Ghép Hình Pokemon Kawaii Classic)</span>
            </div>

            <div class="student-info">
                <p><strong>Giảng viên hướng dẫn:</strong> [Tên giảng viên]</p>
                <p><strong>Sinh viên thực hiện:</strong></p>
                <p style="margin-left: 30px;">Họ và tên: [Tên sinh viên]</p>
                <p style="margin-left: 30px;">MSSV: [Mã số sinh viên]</p>
                <p style="margin-left: 30px;">Lớp: [Tên lớp]</p>
            </div>

            <div class="footer-cover">
                <p><strong>Thành phố Hồ Chí Minh, tháng 01 năm 2026</strong></p>
            </div>
        </div>

        <!-- MỤC LỤC -->
        <div class="page-break"></div>
        <h1>MỤC LỤC</h1>
        <div class="toc">
            <div class="toc-item">
                <span class="section-number">PHẦN 1.</span> MỞ ĐẦU
                <div style="margin-left: 40px;">
                    <div class="toc-item">1.1. Giới thiệu ứng dụng</div>
                    <div class="toc-item">1.2. Mục tiêu đồ án</div>
                    <div class="toc-item">1.3. Công nghệ sử dụng</div>
                </div>
            </div>

            <div class="toc-item">
                <span class="section-number">PHẦN 2.</span> PHÂN TÍCH THUẬT TOÁN
                <div style="margin-left: 40px;">
                    <div class="toc-item">2.1. Fisher-Yates Shuffle Algorithm</div>
                    <div class="toc-item">2.2. Pathfinding với Ràng Buộc Lượt Rẽ</div>
                    <div class="toc-item">2.3. Hint Finding Algorithm</div>
                    <div class="toc-item">2.4. Board Generation Algorithm</div>
                    <div class="toc-item">2.5. Ice Placement Algorithm</div>
                    <div class="toc-item">2.6. Move Validation & Board Update</div>
                    <div class="toc-item">2.7. Board Clear Check Algorithm</div>
                </div>
            </div>

            <div class="toc-item">
                <span class="section-number">PHẦN 3.</span> THIẾT KẾ HỆ THỐNG
                <div style="margin-left: 40px;">
                    <div class="toc-item">3.1. Kiến trúc hệ thống</div>
                    <div class="toc-item">3.2. Cấu trúc dữ liệu</div>
                    <div class="toc-item">3.3. Sơ đồ luồng xử lý</div>
                </div>
            </div>

            <div class="toc-item">
                <span class="section-number">PHẦN 4.</span> KẾT QUẢ VÀ ĐÁNH GIÁ
                <div style="margin-left: 40px;">
                    <div class="toc-item">4.1. Kết quả đạt được</div>
                    <div class="toc-item">4.2. So sánh độ phức tạp</div>
                    <div class="toc-item">4.3. Đánh giá và nhận xét</div>
                </div>
            </div>

            <div class="toc-item">
                <span class="section-number">PHẦN 5.</span> KẾT LUẬN VÀ HƯỚNG PHÁT TRIỂN
            </div>
        </div>

        <!-- PHẦN 1: MỞ ĐẦU -->
        <div class="page-break"></div>
        <h1>PHẦN 1: MỞ ĐẦU</h1>

        <h2>1.1. Giới thiệu ứng dụng</h2>
        <p>PokeKawaii là một ứng dụng game ghép hình theo phong cách Pikachu Kawaii Classic, được phát triển nhằm minh họa việc áp dụng các thuật toán và cấu trúc dữ liệu trong lập trình game. Game lấy cảm hứng từ thể loại ghép hình Mahjong truyền thống, kết hợp với đồ họa Pokemon để tạo nên một trải nghiệm chơi game thú vị và giàu tính giáo dục.</p>

        <p>Ứng dụng được xây dựng theo mô hình Client-Server, với Backend sử dụng Python FastAPI để xử lý logic game và Frontend sử dụng React để hiển thị giao diện người dùng. Điểm đặc biệt của dự án là việc tích hợp nhiều thuật toán kinh điển trong khoa học máy tính như BFS (Breadth-First Search), Fisher-Yates Shuffle, Hash Map, và các thuật toán tìm đường với ràng buộc.</p>

        <h2>1.2. Mục tiêu đồ án</h2>
        <p>Đồ án được thực hiện với các mục tiêu chính sau:</p>
        <ul>
            <li><strong>Ứng dụng kiến thức về giải thuật:</strong> Triển khai các thuật toán sắp xếp, tìm kiếm, đệ quy, tham lam, và đồ thị để giải quyết các bài toán cụ thể trong game.</li>
            <li><strong>Phân tích hiệu năng và lựa chọn thuật toán:</strong> So sánh độ phức tạp thời gian và không gian của các thuật toán khác nhau, từ đó lựa chọn thuật toán tối ưu cho từng chức năng.</li>
            <li><strong>Rèn luyện kỹ năng lập trình:</strong> Thực hành kỹ năng lập trình thực tế, từ thiết kế kiến trúc hệ thống đến triển khai và tối ưu hóa code.</li>
            <li><strong>Trình bày báo cáo kỹ thuật:</strong> Phát triển khả năng phân tích, đánh giá và trình bày các thuật toán một cách khoa học và chuyên nghiệp.</li>
        </ul>

        <h2>1.3. Công nghệ sử dụng</h2>

        <h3>1.3.1. Backend - Python FastAPI</h3>
        <ul>
            <li><strong>FastAPI 0.109.0:</strong> Framework web hiện đại, hiệu năng cao cho Python, hỗ trợ async/await và tự động generate API documentation.</li>
            <li><strong>Uvicorn 0.27.0:</strong> ASGI server để chạy ứng dụng FastAPI.</li>
            <li><strong>Pydantic 2.5.3:</strong> Thư viện validation dữ liệu mạnh mẽ, đảm bảo type safety.</li>
        </ul>

        <h3>1.3.2. Frontend - React</h3>
        <ul>
            <li><strong>React 18.2.0:</strong> Thư viện JavaScript để xây dựng user interface.</li>
            <li><strong>Vite 5.0.11:</strong> Build tool hiện đại, nhanh chóng cho React applications.</li>
            <li><strong>Axios 1.6.5:</strong> HTTP client để giao tiếp với Backend API.</li>
        </ul>

        <h3>1.3.3. Deployment & DevOps</h3>
        <ul>
            <li><strong>Docker:</strong> Containerization cho cả Backend và Frontend.</li>
            <li><strong>Render:</strong> Cloud platform để deploy ứng dụng production.</li>
            <li><strong>Git & GitHub:</strong> Version control và code repository.</li>
        </ul>

        <!-- PHẦN 2: PHÂN TÍCH THUẬT TOÁN -->
        <div class="page-break"></div>
        <h1>PHẦN 2: PHÂN TÍCH THUẬT TOÁN</h1>

        <h2>2.1. Fisher-Yates Shuffle Algorithm</h2>

        <h3>2.1.1. Mô tả bài toán</h3>
        <p>Trong game PokeKawaii, cần phân bố ngẫu nhiên các Pokemon trên bàn chơi sao cho mỗi ván chơi có bố cục khác nhau, đồng thời đảm bảo tính công bằng (mọi hoán vị có xác suất bằng nhau).</p>

        <h3>2.1.2. Lý do lựa chọn thuật toán</h3>
        <p>Fisher-Yates Shuffle (còn gọi là Knuth Shuffle) được chọn vì:</p>
        <ul>
            <li>Độ phức tạp thời gian O(n) - tuyến tính, rất hiệu quả</li>
            <li>Độ phức tạp không gian O(1) - xáo trộn tại chỗ (in-place)</li>
            <li>Đảm bảo không thiên vị - mọi hoán vị có xác suất 1/n!</li>
            <li>Dễ hiểu và triển khai</li>
        </ul>

        <h3>2.1.3. Thuật toán áp dụng</h3>
        <div class="algorithm-box">
            <strong>Thuật toán Fisher-Yales Shuffle:</strong>
            <ol style="margin-top: 10px;">
                <li>Duyệt mảng từ cuối về đầu (index từ n-1 đến 1)</li>
                <li>Tại mỗi vị trí i, chọn ngẫu nhiên index j trong khoảng [0, i]</li>
                <li>Hoán đổi phần tử tại vị trí i với phần tử tại vị trí j</li>
                <li>Tiếp tục cho đến khi hoàn thành</li>
            </ol>
        </div>

        <h3>2.1.4. Source code</h3>
        <div class="code-block">
def fisher_yates_shuffle(items):
    &quot;&quot;&quot;
    Xáo trộn danh sách tại chỗ (in-place)
    Time Complexity: O(n)
    Space Complexity: O(1)
    &quot;&quot;&quot;
    n = len(items)

    # Duyệt từ cuối về đầu
    for i in range(n - 1, 0, -1):
        # Chọn ngẫu nhiên index j từ [0, i]
        j = random.randint(0, i)

        # Hoán đổi items[i] với items[j]
        items[i], items[j] = items[j], items[i]

    return items
        </div>

        <h3>2.1.5. Phân tích độ phức tạp</h3>
        <div class="complexity-box">
            <strong>Độ phức tạp thời gian:</strong> O(n)
            <ul style="margin: 5px 0 5px 20px;">
                <li>Duyệt qua n phần tử đúng 1 lần</li>
                <li>Mỗi phép hoán đổi là O(1)</li>
                <li>Tổng: O(n)</li>
            </ul>

            <strong>Độ phức tạp không gian:</strong> O(1)
            <ul style="margin: 5px 0 5px 20px;">
                <li>Chỉ sử dụng biến tạm i, j</li>
                <li>Xáo trộn tại chỗ, không tạo mảng mới</li>
            </ul>
        </div>

        <h3>2.1.6. So sánh với các thuật toán khác</h3>
        <table>
            <tr>
                <th>Thuật toán</th>
                <th>Time Complexity</th>
                <th>Space Complexity</th>
                <th>Unbiased</th>
            </tr>
            <tr>
                <td><strong>Fisher-Yates Shuffle</strong></td>
                <td>O(n)</td>
                <td>O(1)</td>
                <td>✅ Yes</td>
            </tr>
            <tr>
                <td>Naive Shuffle (sort random)</td>
                <td>O(n log n)</td>
                <td>O(n)</td>
                <td>❌ No</td>
            </tr>
            <tr>
                <td>Selection Sampling</td>
                <td>O(n²)</td>
                <td>O(n)</td>
                <td>✅ Yes</td>
            </tr>
        </table>

        <div class="page-break"></div>
        <h2>2.2. Pathfinding với Ràng Buộc Lượt Rẽ</h2>

        <h3>2.2.1. Mô tả bài toán</h3>
        <p>Tìm đường nối giữa hai ô Pokemon giống nhau trên bàn chơi với các ràng buộc:</p>
        <ul>
            <li>Đường đi chỉ gồm các đoạn thẳng (ngang hoặc dọc)</li>
            <li>Tối đa 3 lượt rẽ (thay đổi hướng)</li>
            <li>Không đi qua ô có Pokemon khác</li>
            <li>Có thể đi vòng qua biên bàn chơi</li>
        </ul>

        <h3>2.2.2. Các phương pháp tiếp cận</h3>

        <h4>Phương pháp 1: BFS với Theo Dõi Lượt Rẽ</h4>
        <p>Sử dụng thuật toán BFS (Breadth-First Search) cải tiến:</p>
        <ul>
            <li>State: (row, col, direction, turns, path)</li>
            <li>Queue để duyệt các state theo chiều rộng</li>
            <li>Visited set để tránh lặp vô hạn</li>
            <li>Stop condition: turns > 3</li>
        </ul>

        <div class="complexity-box">
            <strong>BFS Approach:</strong><br>
            Time Complexity: O(rows × cols × 4)<br>
            Space Complexity: O(rows × cols)
        </div>

        <h4>Phương pháp 2: Simplified Pathfinding (Được áp dụng)</h4>
        <p>Thay vì duyệt toàn bộ không gian trạng thái, kiểm tra các loại đường theo thứ tự từ đơn giản đến phức tạp:</p>

        <ol>
            <li><strong>Đường thẳng (0 lượt rẽ):</strong> Cùng hàng hoặc cùng cột</li>
            <li><strong>Đường chữ L (1 lượt rẽ):</strong> Qua 1 điểm góc</li>
            <li><strong>Đường chữ Z/U (2 lượt rẽ):</strong> Qua 2 điểm trung gian</li>
            <li><strong>Đường qua biên (2-3 lượt rẽ):</strong> Đi vòng ra ngoài bàn chơi</li>
        </ol>

        <h3>2.2.3. Lý do lựa chọn Simplified Pathfinding</h3>
        <div class="note-box">
            <strong>Ưu điểm so với BFS:</strong>
            <ul style="margin: 5px 0 0 20px;">
                <li><strong>Early termination:</strong> Dừng ngay khi tìm thấy đường đơn giản (thường xuyên xảy ra)</li>
                <li><strong>Cache-friendly:</strong> Truy cập tuần tự vào grid, tốt cho CPU cache</li>
                <li><strong>Dễ debug:</strong> Logic rõ ràng, dễ theo dõi từng bước</li>
                <li><strong>Hiệu suất thực tế:</strong> Trong game, đường đơn giản (0-1 rẽ) chiếm ~70-80% trường hợp</li>
            </ul>
        </div>

        <h3>2.2.4. Source code - Kiểm tra đường thẳng (0 rẽ)</h3>
        <div class="code-block">
def check_straight_path(pos1, pos2, grid):
    &quot;&quot;&quot;
    Kiểm tra đường thẳng giữa 2 điểm
    &quot;&quot;&quot;
    # Kiểm tra cùng hàng
    if pos1.row == pos2.row:
        min_col = min(pos1.col, pos2.col)
        max_col = max(pos1.col, pos2.col)

        # Kiểm tra các ô giữa có trống không
        for col in range(min_col + 1, max_col):
            if grid[pos1.row][col].type == &quot;POKEMON&quot;:
                return False

        return MatchResult(
            is_valid=True,
            path=[pos1, pos2],
            turns=0
        )

    # Kiểm tra cùng cột
    if pos1.col == pos2.col:
        min_row = min(pos1.row, pos2.row)
        max_row = max(pos1.row, pos2.row)

        for row in range(min_row + 1, max_row):
            if grid[row][pos1.col].type == &quot;POKEMON&quot;:
                return False

        return MatchResult(
            is_valid=True,
            path=[pos1, pos2],
            turns=0
        )

    return MatchResult(is_valid=False)
        </div>

        <div class="page-break"></div>
        <h3>2.2.5. Source code - Đường chữ L (1 rẽ)</h3>
        <div class="code-block">
def check_l_shaped_path(pos1, pos2, grid):
    &quot;&quot;&quot;
    Kiểm tra đường hình chữ L qua 1 góc
    &quot;&quot;&quot;
    # Thử góc 1: (pos1.row, pos2.col)
    corner1 = Position(pos1.row, pos2.col)

    if is_empty(corner1, grid):
        # Kiểm tra 2 đoạn thẳng
        if is_line_clear_horizontal(pos1.col, corner1.col, pos1.row, grid) and \
           is_line_clear_vertical(corner1.row, pos2.row, corner1.col, grid):
            return MatchResult(
                is_valid=True,
                path=[pos1, corner1, pos2],
                turns=1
            )

    # Thử góc 2: (pos2.row, pos1.col)
    corner2 = Position(pos2.row, pos1.col)

    if is_empty(corner2, grid):
        if is_line_clear_vertical(pos1.row, corner2.row, pos1.col, grid) and \
           is_line_clear_horizontal(corner2.col, pos2.col, pos2.row, grid):
            return MatchResult(
                is_valid=True,
                path=[pos1, corner2, pos2],
                turns=1
            )

    return MatchResult(is_valid=False)
        </div>

        <h3>2.2.6. Phân tích độ phức tạp</h3>
        <table>
            <tr>
                <th>Loại đường</th>
                <th>Time Complexity</th>
                <th>Giải thích</th>
            </tr>
            <tr>
                <td>0 lượt rẽ (thẳng)</td>
                <td>O(max(rows, cols))</td>
                <td>Kiểm tra 1 đường thẳng</td>
            </tr>
            <tr>
                <td>1 lượt rẽ (chữ L)</td>
                <td>O(rows + cols)</td>
                <td>Kiểm tra 2 góc, mỗi góc 2 đoạn thẳng</td>
            </tr>
            <tr>
                <td>2 lượt rẽ (chữ Z/U)</td>
                <td>O(rows × cols)</td>
                <td>Thử mọi hàng/cột làm đường giữa</td>
            </tr>
            <tr>
                <td><strong>Worst case</strong></td>
                <td><strong>O(rows × cols)</strong></td>
                <td>Khi phải kiểm tra hết các loại đường</td>
            </tr>
        </table>

        <div class="complexity-box">
            <strong>Average Case Analysis:</strong>
            <ul style="margin: 5px 0 0 20px;">
                <li>70% trường hợp: Tìm thấy đường ở bước 1-2 (0-1 rẽ) → O(n)</li>
                <li>25% trường hợp: Cần đến bước 3 (2 rẽ) → O(n²)</li>
                <li>5% trường hợp: Không có đường hoặc cần 3 rẽ → O(n²)</li>
                <li><strong>Average: O(n)</strong> với n = max(rows, cols)</li>
            </ul>
        </div>

        <div class="page-break"></div>
        <h2>2.3. Hint Finding Algorithm (Tìm Gợi Ý)</h2>

        <h3>2.3.1. Mô tả bài toán</h3>
        <p>Tìm một cặp Pokemon có thể ghép được (có đường đi hợp lệ) để gợi ý cho người chơi khi bế tắc.</p>

        <h3>2.3.2. Thuật toán áp dụng</h3>
        <p>Sử dụng <strong>Hash Map</strong> kết hợp với <strong>Early Termination</strong>:</p>

        <div class="algorithm-box">
            <strong>Các bước thực hiện:</strong>
            <ol style="margin-top: 10px;">
                <li>Build hash map: nhóm Pokemon theo ID (pokemon_id → List[positions])</li>
                <li>Duyệt qua các loại Pokemon có ≥ 2 vị trí</li>
                <li>Với mỗi loại, thử tất cả các cặp vị trí</li>
                <li>Kiểm tra xem có đường đi hợp lệ không (dùng Pathfinding)</li>
                <li>Return ngay khi tìm thấy cặp hợp lệ đầu tiên (Early Termination)</li>
            </ol>
        </div>

        <h3>2.3.3. Source code</h3>
        <div class="code-block">
def find_hint(game_state):
    &quot;&quot;&quot;
    Tìm một nước đi hợp lệ để gợi ý
    Time Complexity: O(n²) worst case, O(n) average
    Space Complexity: O(n)
    &quot;&quot;&quot;
    grid = game_state.board.grid
    rows, cols = game_state.board.rows, game_state.board.cols

    # Bước 1: Build hash map
    pokemon_positions = {}  # {pokemon_id: [positions]}

    for row in range(rows):
        for col in range(cols):
            cell = grid[row][col]

            # Chỉ xét Pokemon chưa bị đóng băng
            if cell.type == &quot;POKEMON&quot; and not cell.is_frozen:
                if cell.pokemon_id not in pokemon_positions:
                    pokemon_positions[cell.pokemon_id] = []

                pokemon_positions[cell.pokemon_id].append(
                    Position(row, col)
                )

    # Bước 2: Kiểm tra từng loại Pokemon
    for pokemon_id, positions in pokemon_positions.items():
        if len(positions) &lt; 2:
            continue

        # Bước 3: Thử tất cả các cặp
        for i in range(len(positions)):
            for j in range(i + 1, len(positions)):
                pos1 = positions[i]
                pos2 = positions[j]

                # Bước 4: Kiểm tra đường đi
                result = pathfinder.find_path(pos1, pos2, grid)

                if result.is_valid:
                    # Bước 5: Return ngay (Early Termination)
                    return {&quot;pos1&quot;: pos1, &quot;pos2&quot;: pos2, &quot;path&quot;: result.path}

    # Không tìm thấy
    return None
        </div>

        <h3>2.3.4. Phân tích độ phức tạp</h3>
        <div class="complexity-box">
            <strong>Time Complexity Analysis:</strong>
            <ul style="margin: 5px 0 0 20px;">
                <li><strong>Build hash map:</strong> O(rows × cols) = O(n)</li>
                <li><strong>Duyệt các loại Pokemon:</strong> O(20) = O(1)</li>
                <li><strong>Thử các cặp của cùng loại:</strong> O(k²) với k = số Pokemon cùng loại (thường k ≤ 4)</li>
                <li><strong>Kiểm tra đường đi:</strong> O(n²) trong worst case</li>
                <li><strong>Early termination:</strong> Dừng ngay khi tìm thấy → Average O(n)</li>
            </ul>

            <strong>Space Complexity:</strong> O(n) cho hash map
        </div>

        <h3>2.3.5. So sánh với Brute Force</h3>
        <table>
            <tr>
                <th>Phương pháp</th>
                <th>Time Complexity</th>
                <th>Giải thích</th>
            </tr>
            <tr>
                <td>Brute Force</td>
                <td>O(n⁴)</td>
                <td>Duyệt tất cả cặp ô (n²) × kiểm tra đường đi (n²)</td>
            </tr>
            <tr>
                <td><strong>Hash Map + Early Stop</strong></td>
                <td><strong>O(n) average</strong></td>
                <td>Chỉ kiểm tra Pokemon cùng loại + dừng sớm</td>
            </tr>
            <tr>
                <td colspan="3" style="text-align: center; background: #d4edda;">
                    <strong>Cải thiện: ~10,000x nhanh hơn</strong> (với board 8×12)
                </td>
            </tr>
        </table>

        <div class="page-break"></div>
        <h2>2.4. Board Generation Algorithm</h2>

        <h3>2.4.1. Mô tả bài toán</h3>
        <p>Khởi tạo bàn chơi với các yêu cầu:</p>
        <ul>
            <li>Mỗi Pokemon xuất hiện ít nhất 2 lần (để ghép cặp)</li>
            <li>Tổng số ô phải chẵn</li>
            <li>Phân bố ngẫu nhiên nhưng cân bằng</li>
            <li>Thêm đá băng ở level cao</li>
        </ul>

        <h3>2.4.2. Source code</h3>
        <div class="code-block">
def generate_board(rows=8, cols=12, level=1):
    &quot;&quot;&quot;
    Tạo bàn chơi mới
    Time Complexity: O(rows × cols)
    Space Complexity: O(rows × cols)
    &quot;&quot;&quot;
    total_cells = rows * cols

    # Bước 1: Tạo danh sách Pokemon (phải chẵn)
    pokemon_list = []

    # Thêm 2 con của mỗi loại Pokemon (1-20)
    for pokemon_id in range(1, 21):
        pokemon_list.append(pokemon_id)
        pokemon_list.append(pokemon_id)

    # Bước 2: Điền thêm để đủ số ô
    while len(pokemon_list) &lt; total_cells:
        random_id = random.randint(1, 20)
        pokemon_list.append(random_id)
        pokemon_list.append(random_id)  # Luôn thêm cặp

    # Bước 3: Cắt bớt nếu thừa
    pokemon_list = pokemon_list[:total_cells]

    # Bước 4: Xáo trộn bằng Fisher-Yates
    fisher_yates_shuffle(pokemon_list)

    # Bước 5: Điền vào grid
    grid = []
    index = 0
    for row in range(rows):
        grid_row = []
        for col in range(cols):
            cell = Cell(
                type=&quot;POKEMON&quot;,
                pokemon_id=pokemon_list[index],
                is_frozen=False
            )
            grid_row.append(cell)
            index += 1
        grid.append(grid_row)

    # Bước 6: Thêm đá băng nếu level cao
    if level &gt;= 4:
        add_ice_blocks(grid, level)

    return GameBoard(
        grid=grid, rows=rows, cols=cols,
        time_remaining=300, lives=5, level=level, score=0
    )
        </div>

        <h3>2.4.3. Phân tích độ phức tạp</h3>
        <table>
            <tr>
                <th>Bước</th>
                <th>Thao tác</th>
                <th>Time Complexity</th>
            </tr>
            <tr>
                <td>1-3</td>
                <td>Tạo danh sách Pokemon</td>
                <td>O(n)</td>
            </tr>
            <tr>
                <td>4</td>
                <td>Fisher-Yates Shuffle</td>
                <td>O(n)</td>
            </tr>
            <tr>
                <td>5</td>
                <td>Điền vào grid</td>
                <td>O(n)</td>
            </tr>
            <tr>
                <td>6</td>
                <td>Thêm đá băng</td>
                <td>O(k) với k = số đá băng</td>
            </tr>
            <tr>
                <td colspan="2"><strong>Tổng</strong></td>
                <td><strong>O(n)</strong> với n = rows × cols</td>
            </tr>
        </table>

        <div class="page-break"></div>
        <h2>2.5. Ice Placement Algorithm</h2>

        <h3>2.5.1. Mô tả thuật toán</h3>
        <p>Đặt đá băng ngẫu nhiên trên bàn chơi ở level cao, sử dụng Set để tránh trùng lặp vị trí.</p>

        <h3>2.5.2. Source code</h3>
        <div class="code-block">
def add_ice_blocks(grid, level):
    &quot;&quot;&quot;
    Thêm đá băng vào bàn chơi
    Time Complexity: O(k) với k = số đá băng
    Space Complexity: O(k)
    &quot;&quot;&quot;
    rows, cols = len(grid), len(grid[0])

    # Công thức tính số đá băng
    ice_count = min(level - 3, (rows * cols) // 4)

    ice_positions = set()  # Dùng set để tránh trùng

    # Đặt đá băng cho đến khi đủ số lượng
    while len(ice_positions) &lt; ice_count:
        row = random.randint(0, rows - 1)
        col = random.randint(0, cols - 1)

        # Set tự động tránh trùng lặp
        ice_positions.add((row, col))

    # Đánh dấu các ô có đá băng
    for (row, col) in ice_positions:
        grid[row][col].is_frozen = True
        </div>

        <div class="note-box">
            <strong>Tại sao dùng Set?</strong>
            <ul style="margin: 5px 0 0 20px;">
                <li>Set tự động loại bỏ duplicate → Không cần kiểm tra thủ công</li>
                <li>O(1) cho add và contains operations</li>
                <li>Code gọn gàng, dễ hiểu hơn</li>
            </ul>
        </div>

        <h2>2.6. Move Validation & Board Update</h2>

        <h3>2.6.1. Quy trình xử lý nước đi</h3>
        <div class="algorithm-box">
            <strong>Các bước validate và update:</strong>
            <ol style="margin-top: 10px;">
                <li>Kiểm tra 2 Pokemon có cùng loại không</li>
                <li>Kiểm tra không bị đóng băng</li>
                <li>Tìm đường đi hợp lệ (Pathfinding)</li>
                <li>Nếu hợp lệ:
                    <ul>
                        <li>Xóa 2 Pokemon (set to EMPTY)</li>
                        <li>Xóa đá băng liền kề (4 hướng)</li>
                        <li>Cập nhật điểm số</li>
                        <li>Kiểm tra thắng</li>
                    </ul>
                </li>
            </ol>
        </div>

        <h3>2.6.2. Source code - Xóa đá băng liền kề</h3>
        <div class="code-block">
def remove_adjacent_ice(pos, grid):
    &quot;&quot;&quot;
    Xóa đá băng ở 4 ô liền kề (trên, dưới, trái, phải)
    &quot;&quot;&quot;
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    rows, cols = len(grid), len(grid[0])

    for dr, dc in directions:
        new_row = pos.row + dr
        new_col = pos.col + dc

        # Kiểm tra trong bounds
        if 0 &lt;= new_row &lt; rows and 0 &lt;= new_col &lt; cols:
            cell = grid[new_row][new_col]

            # Xóa đá băng
            if cell.is_frozen:
                cell.is_frozen = False
        </div>

        <h2>2.7. Board Clear Check Algorithm</h2>

        <h3>2.7.1. Mô tả</h3>
        <p>Kiểm tra xem đã xóa hết Pokemon trên bàn chơi chưa (điều kiện thắng).</p>

        <h3>2.7.2. Source code</h3>
        <div class="code-block">
def is_board_clear(grid):
    &quot;&quot;&quot;
    Kiểm tra xem còn Pokemon nào không
    Time Complexity: O(rows × cols)
    Space Complexity: O(1)
    &quot;&quot;&quot;
    for row in grid:
        for cell in row:
            if cell.type == &quot;POKEMON&quot;:
                return False  # Còn Pokemon → chưa thắng

    return True  # Hết Pokemon → Thắng!
        </div>

        <div class="complexity-box">
            <strong>Độ phức tạp:</strong> O(n) với n = rows × cols<br>
            <strong>Không gian:</strong> O(1) - chỉ duyệt, không lưu trữ
        </div>

        <!-- PHẦN 3: THIẾT KẾ HỆ THỐNG -->
        <div class="page-break"></div>
        <h1>PHẦN 3: THIẾT KẾ HỆ THỐNG</h1>

        <h2>3.1. Kiến trúc hệ thống</h2>

        <h3>3.1.1. Kiến trúc tổng quan</h3>
        <p>Hệ thống PokeKawaii được thiết kế theo mô hình Client-Server với kiến trúc 3 tầng:</p>

        <div class="diagram">
┌─────────────────┐
│   Browser       │  ← User Interface Layer
│  (localhost)    │
└────────┬────────┘
         │ HTTP/HTTPS
         ▼
┌─────────────────────┐
│   Frontend          │  ← Presentation Layer
│   React + Vite      │
│   (Port 3000/80)    │
└────────┬────────────┘
         │ Axios API Calls
         ▼
┌─────────────────────┐
│   Backend           │  ← Business Logic Layer
│   FastAPI + Python  │
│   (Port 8000)       │
└────────┬────────────┘
         │
         ▼
┌─────────────────────┐
│   In-Memory Store   │  ← Data Layer
│   Dict[game_id,     │
│   GameState]        │
└─────────────────────┘
        </div>

        <h3>3.1.2. Cấu trúc thư mục Backend</h3>
        <div class="diagram">
backend/
├── app/
│   ├── main.py                 # FastAPI application entry
│   ├── api/
│   │   └── routes.py           # API endpoints
│   ├── models/
│   │   └── game.py             # Pydantic data models
│   ├── services/
│   │   ├── game_service.py     # Game logic
│   │   └── pokemon_data.py     # Pokemon configuration
│   └── core/
│       └── pathfinder.py       # Pathfinding algorithms
├── requirements.txt
└── run.py
        </div>

        <h3>3.1.3. Cấu trúc thư mục Frontend</h3>
        <div class="diagram">
frontend/
├── src/
│   ├── App.jsx                 # Root component
│   ├── components/
│   │   ├── GameBoard.jsx       # Main game board
│   │   ├── Cell.jsx            # Individual cell
│   │   ├── MatchLine.jsx       # SVG animation
│   │   └── GameInfo.jsx        # Score/Lives display
│   ├── services/
│   │   └── api.js              # API client (Axios)
│   └── main.jsx                # Entry point
├── public/
│   └── _redirects              # SPA routing config
├── index.html
├── package.json
└── vite.config.js
        </div>

        <div class="page-break"></div>
        <h2>3.2. Cấu trúc dữ liệu</h2>

        <h3>3.2.1. Backend Data Models</h3>

        <h4>Cell (Ô trên bàn chơi)</h4>
        <div class="code-block">
class Cell(BaseModel):
    type: CellType          # EMPTY | POKEMON | ICE
    pokemon_id: int         # 1-20 (ID Pokemon)
    is_frozen: bool         # True nếu bị phủ đá băng
        </div>

        <h4>Position (Vị trí tọa độ)</h4>
        <div class="code-block">
class Position(BaseModel):
    row: int                # Hàng (0-indexed)
    col: int                # Cột (0-indexed)
        </div>

        <h4>GameBoard (Bàn chơi)</h4>
        <div class="code-block">
class GameBoard(BaseModel):
    grid: List[List[Cell]]          # Ma trận 2D
    rows: int                       # Số hàng (8)
    cols: int                       # Số cột (12)
    time_remaining: int             # Thời gian còn lại
    lives: int                      # Số mạng
    level: int                      # Level hiện tại
    score: int                      # Điểm số
        </div>

        <h3>3.2.2. In-Memory Storage</h3>
        <div class="code-block">
# Backend lưu trữ games trong RAM
games: Dict[str, GameState] = {}

# Key: game_id (UUID string)
# Value: GameState object (toàn bộ trạng thái game)
        </div>

        <div class="note-box">
            <strong>Lý do sử dụng In-Memory Storage:</strong>
            <ul style="margin: 5px 0 0 20px;">
                <li>Truy cập cực nhanh: O(1) lookup</li>
                <li>Đơn giản, phù hợp với demo/prototype</li>
                <li>Không cần setup database</li>
                <li>Hạn chế: Mất dữ liệu khi restart server</li>
            </ul>
        </div>

        <div class="page-break"></div>
        <h2>3.3. Sơ đồ luồng xử lý</h2>

        <h3>3.3.1. Luồng tạo game mới</h3>
        <div class="diagram">
┌─────────────┐
│   Client    │
│  Click      │
│ "New Game"  │
└──────┬──────┘
       │
       │ POST /api/game/new?level=1
       ▼
┌────────────────────────┐
│  Backend API Handler   │
└──────┬─────────────────┘
       │
       ▼
┌────────────────────────┐
│  GameService           │
│  .create_new_game()    │
└──────┬─────────────────┘
       │
       ├─► Generate Pokemon list (40 items)
       ├─► Fisher-Yates Shuffle
       ├─► Create 8×12 grid
       ├─► Add ice blocks (if level ≥ 4)
       │
       ▼
┌────────────────────────┐
│  Save to games Dict    │
│  games[game_id] = state│
└──────┬─────────────────┘
       │
       │ Return {game_id, game_state}
       ▼
┌────────────────────────┐
│  Client receives       │
│  Render game board     │
└────────────────────────┘
        </div>

        <h3>3.3.2. Luồng thực hiện nước đi</h3>
        <div class="diagram">
┌─────────────┐
│   Client    │
│ Click 2     │
│  Pokemon    │
└──────┬──────┘
       │
       │ POST /api/game/{id}/move
       │ Body: {pos1, pos2}
       ▼
┌────────────────────────┐
│  Validate Pokemon      │
│  - Cùng loại?          │
│  - Không frozen?       │
└──────┬─────────────────┘
       │ ✓
       ▼
┌────────────────────────┐
│  Pathfinding           │
│  - Check straight (0)  │
│  - Check L-shape (1)   │
│  - Check Z-shape (2)   │
│  - Check border (3)    │
└──────┬─────────────────┘
       │
       ├─► Valid path found?
       │   ├─ YES ──┐
       │   └─ NO ───┼─► Return {success: false}
       │            │
       ▼            ▼
┌────────────┐  ┌──────────────┐
│ Remove     │  │ Client shows │
│ Pokemon    │  │ error message│
│ from grid  │  └──────────────┘
└──────┬─────┘
       │
       ├─► Remove adjacent ice (4 directions)
       ├─► Update score
       ├─► Check if board clear → Victory?
       │
       ▼
┌────────────────────────┐
│  Has valid moves left? │
└──────┬─────────────────┘
       │
       ├─ NO ──► Auto shuffle board
       │
       ▼
┌────────────────────────┐
│  Return updated state  │
│  {success, path, score}│
└──────┬─────────────────┘
       │
       ▼
┌────────────────────────┐
│  Client updates UI     │
│  - Animate match line  │
│  - Remove Pokemon      │
│  - Update score/lives  │
└────────────────────────┘
        </div>

        <div class="page-break"></div>
        <h3>3.3.3. Luồng gợi ý (Hint)</h3>
        <div class="diagram">
┌─────────────┐
│   Client    │
│ Click Hint  │
└──────┬──────┘
       │
       │ POST /api/game/{id}/hint
       ▼
┌────────────────────────┐
│  Build Hash Map        │
│  pokemon_id → [pos]    │
└──────┬─────────────────┘
       │
       ▼
┌────────────────────────┐
│  For each Pokemon type │
│  with ≥ 2 instances    │
└──────┬─────────────────┘
       │
       ▼
┌────────────────────────┐
│  Try all pairs         │
│  Check pathfinding     │
└──────┬─────────────────┘
       │
       ├─► Found valid pair?
       │   ├─ YES ──► Return {pos1, pos2}
       │   └─ NO ───► Continue to next pair
       │
       ▼
┌────────────────────────┐
│  No hints found        │
│  Auto shuffle board    │
└────────────────────────┘
        </div>

        <!-- PHẦN 4: KẾT QUẢ VÀ ĐÁNH GIÁ -->
        <div class="page-break"></div>
        <h1>PHẦN 4: KẾT QUẢ VÀ ĐÁNH GIÁ</h1>

        <h2>4.1. Kết quả đạt được</h2>

        <h3>4.1.1. Chức năng đã hoàn thành</h3>
        <table>
            <tr>
                <th>Chức năng</th>
                <th>Trạng thái</th>
                <th>Thuật toán sử dụng</th>
            </tr>
            <tr>
                <td>Tạo game mới</td>
                <td>✅ Hoàn thành</td>
                <td>Fisher-Yates Shuffle, Board Generation</td>
            </tr>
            <tr>
                <td>Ghép cặp Pokemon</td>
                <td>✅ Hoàn thành</td>
                <td>Simplified Pathfinding (0-3 turns)</td>
            </tr>
            <tr>
                <td>Gợi ý nước đi</td>
                <td>✅ Hoàn thành</td>
                <td>Hash Map + Early Termination</td>
            </tr>
            <tr>
                <td>Xáo bàn</td>
                <td>✅ Hoàn thành</td>
                <td>Fisher-Yates Shuffle</td>
            </tr>
            <tr>
                <td>Hệ thống điểm</td>
                <td>✅ Hoàn thành</td>
                <td>Score calculation based on turns</td>
            </tr>
            <tr>
                <td>Hệ thống mạng</td>
                <td>✅ Hoàn thành</td>
                <td>State management</td>
            </tr>
            <tr>
                <td>Đá băng</td>
                <td>✅ Hoàn thành</td>
                <td>Random placement with Set</td>
            </tr>
            <tr>
                <td>Animation UI</td>
                <td>✅ Hoàn thành</td>
                <td>SVG path drawing, CSS animations</td>
            </tr>
            <tr>
                <td>Docker deployment</td>
                <td>✅ Hoàn thành</td>
                <td>Multi-stage build, Docker Compose</td>
            </tr>
            <tr>
                <td>Cloud deployment</td>
                <td>✅ Hoàn thành</td>
                <td>Render (Backend + Frontend)</td>
            </tr>
        </table>

        <h3>4.1.2. Screenshots giao diện</h3>
        <div class="image-placeholder">
            <p style="color: #666;">Screenshot 1: Giao diện game chính</p>
            <p style="font-size: 11pt; margin-top: 10px;">[Chèn ảnh màn hình game đang chơi]</p>
        </div>

        <div class="image-placeholder">
            <p style="color: #666;">Screenshot 2: Animation đường nối khi ghép thành công</p>
            <p style="font-size: 11pt; margin-top: 10px;">[Chèn ảnh animation đường nối xanh lá]</p>
        </div>

        <div class="image-placeholder">
            <p style="color: #666;">Screenshot 3: Hint system và ice blocks</p>
            <p style="font-size: 11pt; margin-top: 10px;">[Chèn ảnh gợi ý và đá băng]</p>
        </div>

        <div class="page-break"></div>
        <h2>4.2. So sánh độ phức tạp các thuật toán</h2>

        <h3>4.2.1. Bảng tổng hợp</h3>
        <table>
            <tr>
                <th>Thuật toán</th>
                <th>Time Complexity</th>
                <th>Space Complexity</th>
                <th>Ghi chú</th>
            </tr>
            <tr>
                <td>Fisher-Yates Shuffle</td>
                <td>O(n)</td>
                <td>O(1)</td>
                <td>In-place, unbiased</td>
            </tr>
            <tr>
                <td>Simplified Pathfinding</td>
                <td>O(n²) worst, O(n) avg</td>
                <td>O(n²)</td>
                <td>Early termination</td>
            </tr>
            <tr>
                <td>BFS Pathfinding</td>
                <td>O(n × 4)</td>
                <td>O(n)</td>
                <td>State space search</td>
            </tr>
            <tr>
                <td>Hint Finding</td>
                <td>O(n²) worst, O(n) avg</td>
                <td>O(n)</td>
                <td>Hash map optimization</td>
            </tr>
            <tr>
                <td>Board Generation</td>
                <td>O(n)</td>
                <td>O(n)</td>
                <td>Linear time</td>
            </tr>
            <tr>
                <td>Ice Placement</td>
                <td>O(k)</td>
                <td>O(k)</td>
                <td>k = ice count</td>
            </tr>
            <tr>
                <td>Board Clear Check</td>
                <td>O(n)</td>
                <td>O(1)</td>
                <td>Single pass</td>
            </tr>
        </table>
        <p style="text-align: center; font-style: italic; margin-top: 5px;">
            (n = rows × cols = 96 cho board 8×12)
        </p>

        <h3>4.2.2. Phân tích hiệu suất thực tế</h3>

        <h4>Test Case: Board 8×12 (96 cells)</h4>
        <table>
            <tr>
                <th>Thao tác</th>
                <th>Thời gian trung bình</th>
                <th>Số lần gọi/game</th>
            </tr>
            <tr>
                <td>Tạo board mới</td>
                <td>&lt; 1ms</td>
                <td>1</td>
            </tr>
            <tr>
                <td>Pathfinding (ghép cặp)</td>
                <td>0.1-0.5ms</td>
                <td>~40-50</td>
            </tr>
            <tr>
                <td>Hint finding</td>
                <td>1-3ms</td>
                <td>~5-10</td>
            </tr>
            <tr>
                <td>Board shuffle</td>
                <td>&lt; 1ms</td>
                <td>~2-3</td>
            </tr>
            <tr>
                <td colspan="2"><strong>Tổng thời gian xử lý/game</strong></td>
                <td><strong>~50-100ms</strong></td>
            </tr>
        </table>

        <div class="note-box">
            <strong>Nhận xét:</strong> Tất cả các thuật toán đều chạy rất nhanh (milliseconds), đảm bảo trải nghiệm người chơi mượt mà không có lag.
        </div>

        <div class="page-break"></div>
        <h2>4.3. Đánh giá và nhận xét</h2>

        <h3>4.3.1. Ưu điểm</h3>
        <ul>
            <li><strong>Thiết kế modular:</strong> Tách biệt rõ ràng giữa models, services, core algorithms → dễ bảo trì và mở rộng</li>
            <li><strong>Tập trung DSA:</strong> Thể hiện rõ các giải thuật kinh điển (BFS, Fisher-Yates, Hash Map, Pathfinding)</li>
            <li><strong>Tối ưu hiệu suất:</strong> Early termination, hash maps cho O(1) lookup, simplified pathfinding</li>
            <li><strong>Scalable architecture:</strong> Có thể điều chỉnh kích thước bàn chơi (mặc định 8×12)</li>
            <li><strong>Production-ready:</strong> Error handling, type validation (Pydantic), HTTP status codes chuẩn</li>
            <li><strong>Full-stack deployment:</strong> Docker, Render cloud, CI/CD ready</li>
        </ul>

        <h3>4.3.2. Hạn chế</h3>
        <ul>
            <li><strong>In-Memory Storage:</strong> Dữ liệu mất khi restart server → Cần database cho production thực tế</li>
            <li><strong>Single-player only:</strong> Chưa hỗ trợ multiplayer mode</li>
            <li><strong>No persistence:</strong> Không lưu lịch sử game, leaderboard</li>
            <li><strong>Limited animations:</strong> Animation cơ bản, chưa có particle effects, sound</li>
        </ul>

        <h3>4.3.3. Kiến thức DSA đã áp dụng</h3>
        <table>
            <tr>
                <th>Chủ đề DSA</th>
                <th>Ứng dụng trong game</th>
            </tr>
            <tr>
                <td><strong>Graph Algorithms</strong></td>
                <td>BFS pathfinding với ràng buộc lượt rẽ</td>
            </tr>
            <tr>
                <td><strong>Randomization</strong></td>
                <td>Fisher-Yates shuffle để phân bố Pokemon</td>
            </tr>
            <tr>
                <td><strong>Hash Tables</strong></td>
                <td>Group Pokemon theo loại cho hint system</td>
            </tr>
            <tr>
                <td><strong>Greedy Algorithms</strong></td>
                <td>Simplified pathfinding (thử đường đơn giản trước)</td>
            </tr>
            <tr>
                <td><strong>2D Arrays</strong></td>
                <td>Grid representation của bàn chơi</td>
            </tr>
            <tr>
                <td><strong>State Management</strong></td>
                <td>Game state tracking (board, score, lives, etc.)</td>
            </tr>
            <tr>
                <td><strong>Space-Time Tradeoff</strong></td>
                <td>Hash map tốn O(n) space nhưng tăng tốc từ O(n²) → O(1)</td>
            </tr>
        </table>

        <!-- PHẦN 5: KẾT LUẬN -->
        <div class="page-break"></div>
        <h1>PHẦN 5: KẾT LUẬN VÀ HƯỚNG PHÁT TRIỂN</h1>

        <h2>5.1. Kết luận</h2>
        <p>Đồ án PokeKawaii đã thành công trong việc áp dụng các kiến thức về Phân tích Thiết kế Giải thuật vào một ứng dụng game thực tế. Qua quá trình thực hiện, nhóm đã:</p>

        <ul>
            <li>Triển khai thành công 7 thuật toán chính với độ phức tạp thời gian từ O(1) đến O(n²)</li>
            <li>So sánh và lựa chọn thuật toán tối ưu cho từng chức năng (Simplified Pathfinding vs BFS, Hash Map vs Brute Force)</li>
            <li>Xây dựng được kiến trúc hệ thống hoàn chỉnh với Backend FastAPI và Frontend React</li>
            <li>Deploy thành công ứng dụng lên cloud platform (Render) với Docker containerization</li>
            <li>Đạt hiệu suất xử lý tốt (~50-100ms/game) đảm bảo trải nghiệm người chơi mượt mà</li>
        </ul>

        <p>Đồ án không chỉ là một game giải trí mà còn là một ví dụ minh họa xuất sắc về việc áp dụng DSA (Data Structures & Algorithms) vào lập trình thực tế, phù hợp cho mục đích học tập và demo kỹ năng lập trình.</p>

        <h2>5.2. Hướng phát triển</h2>

        <h3>5.2.1. Tính năng mới</h3>
        <ul>
            <li><strong>Database Integration:</strong> Thêm PostgreSQL/MongoDB để lưu game history, user profiles, leaderboard</li>
            <li><strong>Multiplayer Mode:</strong> Sử dụng WebSocket cho chế độ chơi real-time 2 người</li>
            <li><strong>AI Solver:</strong> Implement AI agent tự giải game (A* algorithm, backtracking)</li>
            <li><strong>Power-ups:</strong> Thêm item đặc biệt (bomb xóa vùng, freeze time, extra lives)</li>
            <li><strong>Achievement System:</strong> Huy chương, thành tích, daily challenges</li>
        </ul>

        <h3>5.2.2. Cải tiến kỹ thuật</h3>
        <ul>
            <li><strong>Dynamic Difficulty:</strong> Điều chỉnh số lượt rẽ tối đa theo level</li>
            <li><strong>Caching Layer:</strong> Redis cho session management và leaderboard</li>
            <li><strong>Mobile Responsive:</strong> Tối ưu cho thiết bị di động (touch events, adaptive layout)</li>
            <li><strong>Animation Polish:</strong> Particle effects, shake animation, sound effects</li>
            <li><strong>Internationalization:</strong> Hỗ trợ đa ngôn ngữ (i18n)</li>
        </ul>

        <h3>5.2.3. Tối ưu thuật toán</h3>
        <ul>
            <li><strong>Parallel Processing:</strong> Multi-threading cho hint finding trên board lớn</li>
            <li><strong>Memoization:</strong> Cache kết quả pathfinding cho các cặp vị trí đã kiểm tra</li>
            <li><strong>A* Pathfinding:</strong> Thay thế BFS bằng A* với heuristic tốt hơn</li>
        </ul>

        <div class="page-break"></div>
        <h2>5.3. Bài học kinh nghiệm</h2>

        <h3>5.3.1. Kỹ thuật</h3>
        <ul>
            <li>Lựa chọn thuật toán phù hợp quan trọng hơn thuật toán phức tạp (Simplified Pathfinding thắng BFS)</li>
            <li>Early termination và hash maps có thể cải thiện hiệu suất đáng kể (10,000x với Hint Finding)</li>
            <li>Space-time tradeoff là công cụ mạnh mẽ để tối ưu (trade O(n) space để có O(1) lookup)</li>
            <li>Test trên data thực tế quan trọng hơn big-O notation (average case vs worst case)</li>
        </ul>

        <h3>5.3.2. Quản lý dự án</h3>
        <ul>
            <li>Thiết kế kiến trúc modular giúp dễ dàng maintain và mở rộng</li>
            <li>Version control (Git) và documentation là yếu tố then chốt</li>
            <li>Docker và cloud deployment đơn giản hóa quá trình deploy</li>
            <li>Code review và testing sớm giúp phát hiện bug nhanh chóng</li>
        </ul>

        <h2>5.4. Lời cảm ơn</h2>
        <p>Em xin chân thành cảm ơn Thầy/Cô [Tên giảng viên] đã hướng dẫn và tạo điều kiện để em hoàn thành đồ án này. Những kiến thức về Phân tích Thiết kế Giải thuật mà em học được trong học phần này sẽ là nền tảng vững chắc cho sự nghiệp lập trình của em sau này.</p>

        <p>Em cũng xin cảm ơn các bạn trong nhóm (nếu có) đã cùng nhau hợp tác và hỗ trợ nhau trong suốt quá trình thực hiện đồ án.</p>

        <div style="text-align: right; margin-top: 50px;">
            <p><strong>Sinh viên thực hiện</strong></p>
            <p style="margin-top: 60px;">[Chữ ký]</p>
            <p><strong>[Họ và tên]</strong></p>
        </div>

        <!-- TÀI LIỆU THAM KHẢO -->
        <div class="page-break"></div>
        <h1>TÀI LIỆU THAM KHẢO</h1>

        <ol style="line-height: 2;">
            <li>Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). <em>Introduction to Algorithms</em> (3rd ed.). MIT Press.</li>

            <li>Knuth, D. E. (1997). <em>The Art of Computer Programming, Volume 2: Seminumerical Algorithms</em> (3rd ed.). Addison-Wesley.</li>

            <li>FastAPI Documentation. (2024). <em>FastAPI - Modern Web Framework for Python</em>. https://fastapi.tiangolo.com/</li>

            <li>React Documentation. (2024). <em>React - A JavaScript Library for Building User Interfaces</em>. https://react.dev/</li>

            <li>Docker Documentation. (2024). <em>Docker - Containerization Platform</em>. https://docs.docker.com/</li>

            <li>Render Documentation. (2024). <em>Render - Cloud Application Platform</em>. https://render.com/docs</li>

            <li>PokeAPI. (2024). <em>The RESTful Pokémon API</em>. https://pokeapi.co/</li>

            <li>GitHub Repository. (2026). <em>PokeKawaii Source Code</em>. https://github.com/KiRzEa/Pikachu</li>
        </ol>

        <!-- PHỤ LỤC -->
        <div class="page-break"></div>
        <h1>PHỤ LỤC</h1>

        <h2>A. Link Demo & Source Code</h2>
        <ul style="font-size: 12pt; line-height: 2;">
            <li><strong>GitHub Repository:</strong> https://github.com/KiRzEa/Pikachu</li>
            <li><strong>Live Demo (Frontend):</strong> https://pikachu-fe.onrender.com</li>
            <li><strong>API Documentation:</strong> https://pokekawaii-backend.onrender.com/docs</li>
            <li><strong>Game Analysis Document:</strong> PHAN_TICH_GAME_POKEKAWAII.html</li>
            <li><strong>Docker Guide:</strong> README_DOCKER.md</li>
            <li><strong>Render Deployment Guide:</strong> README_RENDER.md</li>
        </ul>

        <h2>B. Hướng dẫn chạy local</h2>

        <h3>B.1. Backend</h3>
        <div class="code-block">
# Clone repository
git clone https://github.com/KiRzEa/Pikachu.git
cd Pikachu/backend

# Install dependencies
pip install -r requirements.txt

# Run server
python run.py

# Server chạy tại: http://localhost:8000
# API Docs: http://localhost:8000/docs
        </div>

        <h3>B.2. Frontend</h3>
        <div class="code-block">
# Vào thư mục frontend
cd Pikachu/frontend

# Install dependencies
npm install

# Run development server
npm run dev

# Frontend chạy tại: http://localhost:3000
        </div>

        <h3>B.3. Docker</h3>
        <div class="code-block">
# Build và chạy cả hai services
docker-compose up --build

# Frontend: http://localhost
# Backend: http://localhost:8000
        </div>

        <div style="text-align: center; margin-top: 100px; font-size: 14pt;">
            <strong>--- HẾT ---</strong>
        </div>
    </div>
</body>
</html>